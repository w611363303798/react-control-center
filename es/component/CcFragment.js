import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import * as helper from '../core/helper';
import React, { Component, Fragment } from 'react';
import { MODULE_DEFAULT, ERR, CC_FRAGMENT_PREFIX, CC_DISPATCHER } from '../support/constant';
import dispatch from '../core/dispatch';
import setState from '../core/set-state';
import setGlobalState from '../core/set-global-state';
import emit from '../core/emit';
import ccContext from '../cc-context';
import util from '../support/util';
var ccClassKey_ccClassContext_ = ccContext.ccClassKey_ccClassContext_,
    fragmentFeature_classKey_ = ccContext.fragmentFeature_classKey_,
    ccKey_ref_ = ccContext.ccKey_ref_;

function getFeatureStr(stateToPropMapping) {
  var prefixedPropKeys = Object.keys(stateToPropMapping);
  var module_mapAllStateToProp_ = {};
  var index_targetModule_ = {};
  prefixedPropKeys.sort();
  prefixedPropKeys.forEach(function (prefixedKey, index) {
    if (!util.isPrefixedKeyValid(prefixedKey)) {
      throw me(ERR.CC_CLASS_KEY_OF_STATE_TO_PROP_MAPPING_INVALID, "error occurred in cc fragment");
    }

    var _prefixedKey$split = prefixedKey.split('/'),
        targetModule = _prefixedKey$split[0],
        targetKey = _prefixedKey$split[1];

    index_targetModule_[index] = {
      targetModule: targetModule,
      targetKey: targetKey
    };

    if (targetKey === '*') {
      module_mapAllStateToProp_[targetModule] = true;
    }
  });
  var strArr = [];
  prefixedPropKeys.forEach(function (prefixedKey, index) {
    var targetModule = index_targetModule_[index];

    if (module_mapAllStateToProp_[targetModule] === true) {
      var str = targetModule + "/*";

      if (!strArr.includes(str)) {
        strArr.push(str);
      } else {
        util.justWarning("prefixedKey:" + prefixedKey + " will be ignored in stateToPropMapping because of existing prefixedKey:" + str);
      }
    } else {
      strArr.push(prefixedKey);
    }
  });
  return strArr.join(',');
}

function getFragmentClassKey(stateToPropMapping) {
  var featureStr = getFeatureStr(stateToPropMapping);
  var targetClassKey = fragmentFeature_classKey_[featureStr];

  if (targetClassKey) {
    return targetClassKey;
  } else {
    var oldFragmentNameCount = ccContext.fragmentNameCount;
    var fragmentNameCount = oldFragmentNameCount + 1;
    ccContext.fragmentNameCount = fragmentNameCount;
    targetClassKey = CC_FRAGMENT_PREFIX + "_" + fragmentNameCount;
    fragmentFeature_classKey_[featureStr] = targetClassKey;
    return targetClassKey;
  }
}

var CcFragment =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(CcFragment, _Component);

  function CcFragment(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;

    if (!ccKey_ref_[CC_DISPATCHER]) {
      throw util.makeError(ERR.CC_NO_DISPATCHER_FOUND);
    }

    var stateToPropMapping = props.stateToPropMapping,
        pm = props.pm,
        isPropStateModuleMode = props.isPropStateModuleMode,
        mm = props.mm,
        ccKey = props.ccKey,
        connect = props.connect;

    var _stateToPropMapping = stateToPropMapping || pm;

    var _isPropStateModuleMode = isPropStateModuleMode || mm;

    if (_stateToPropMapping === undefined) _stateToPropMapping = {};
    if (_isPropStateModuleMode === undefined) _isPropStateModuleMode = false; //allow use connect replace stateToPropMapping, and when use connect, isPropStateModuleMode is always true

    if (connect) {
      _stateToPropMapping = connect;
      _isPropStateModuleMode = true;
    }

    var ccClassKey = getFragmentClassKey(_stateToPropMapping);

    var _helper$computeCcUniq = helper.computeCcUniqueKey(false, ccClassKey, ccKey, true),
        ccUniqueKey = _helper$computeCcUniq.ccUniqueKey,
        isCcUniqueKeyAutoGenerated = _helper$computeCcUniq.isCcUniqueKeyAutoGenerated;

    helper.buildCcClassContext(ccClassKey, MODULE_DEFAULT, [], [], [], [], _stateToPropMapping, _isPropStateModuleMode, true);
    helper.setRef(_assertThisInitialized(_assertThisInitialized(_this)), false, ccClassKey, ccKey, ccUniqueKey, {}); // for CcFragment, just put ccClassKey to module's cc class keys

    var moduleName_ccClassKeys_ = ccContext.moduleName_ccClassKeys_;
    var ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, MODULE_DEFAULT);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);
    _this.$$propState = ccClassKey_ccClassContext_[ccClassKey].propState || {}; // only bind reactForceUpdateRef for CcFragment

    var reactForceUpdateRef = _this.forceUpdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));

    var ccState = {
      module: MODULE_DEFAULT,
      ccClassKey: ccClassKey,
      ccKey: ccKey,
      ccUniqueKey: ccUniqueKey,
      isCcUniqueKeyAutoGenerated: isCcUniqueKeyAutoGenerated,
      stateToPropMapping: _stateToPropMapping,
      renderCount: 0
    };
    _this.cc = {
      ccState: ccState,
      reactForceUpdate: function reactForceUpdate(state, cb) {
        ccState.renderCount += 1;
        reactForceUpdateRef(state, cb);
      }
    };
    _this.state = {
      fragmentParams: {
        propState: _this.$$propState,
        dispatch: dispatch,
        emit: emit,
        setState: setState,
        setGlobalState: setGlobalState
      }
    };
    return _this;
  }

  var _proto = CcFragment.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate() {
    return false;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$cc$ccState = this.cc.ccState,
        ccUniqueKey = _this$cc$ccState.ccUniqueKey,
        ccClassKey = _this$cc$ccState.ccClassKey;
    helper.unsetRef(ccClassKey, ccUniqueKey);
    if (_Component.prototype.componentWillUnmount) _Component.prototype.componentWillUnmount.call(this);
  };

  _proto.render = function render() {
    var children = this.props.children;

    if (typeof children === 'function') {
      return children(this.state.fragmentParams) || React.createElement(Fragment, null);
    } else {
      return children;
    }
  };

  return CcFragment;
}(Component);

export { CcFragment as default };