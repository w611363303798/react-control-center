import * as helper from '../core/helper';
import React, { Component, Fragment } from 'react';
import { MODULE_DEFAULT, ERR, CC_FRAGMENT_PREFIX, CC_DISPATCHER } from '../support/constant';
import dispatch from '../core/dispatch';
import setState from '../core/set-state';
import setGlobalState from '../core/set-global-state';
import emit from '../core/emit';
import ccContext from '../cc-context';
import util from '../support/util';

const { ccClassKey_ccClassContext_, fragmentFeature_classKey_, ccKey_ref_ } = ccContext;

function getFeatureStr(stateToPropMapping) {
  const prefixedPropKeys = Object.keys(stateToPropMapping);
  const module_mapAllStateToProp_ = {};
  const index_targetModule_ = {};
  prefixedPropKeys.sort();

  prefixedPropKeys.forEach((prefixedKey, index) => {
    if (!util.isPrefixedKeyValid(prefixedKey)) {
      throw me(ERR.CC_CLASS_KEY_OF_STATE_TO_PROP_MAPPING_INVALID, `error occurred in cc fragment`);
    }
    const [targetModule, targetKey] = prefixedKey.split('/');
    index_targetModule_[index] = { targetModule, targetKey };
    if (targetKey === '*') {
      module_mapAllStateToProp_[targetModule] = true;
    }
  });

  const strArr = [];
  prefixedPropKeys.forEach((prefixedKey, index) => {
    const targetModule = index_targetModule_[index];
    if (module_mapAllStateToProp_[targetModule] === true) {
      const str = `${targetModule}/*`;
      if (!strArr.includes(str)) {
        strArr.push(str);
      } else {
        util.justWarning(`prefixedKey:${prefixedKey} will be ignored in stateToPropMapping because of existing prefixedKey:${str}`);
      }
    } else {
      strArr.push(prefixedKey);
    }
  });

  return strArr.join(',');
}

function getFragmentClassKey(stateToPropMapping) {
  const featureStr = getFeatureStr(stateToPropMapping);
  let targetClassKey = fragmentFeature_classKey_[featureStr];
  if (targetClassKey) {
    return targetClassKey;
  } else {
    const oldFragmentNameCount = ccContext.fragmentNameCount;
    const fragmentNameCount = oldFragmentNameCount + 1;
    ccContext.fragmentNameCount = fragmentNameCount;
    targetClassKey = `${CC_FRAGMENT_PREFIX}_${fragmentNameCount}`;
    fragmentFeature_classKey_[featureStr] = targetClassKey;
    return targetClassKey;
  }
}

export default class CcFragment extends Component {
  constructor(props, context) {
    super(props, context);
    if (!ccKey_ref_[CC_DISPATCHER]) {
      throw util.makeError(ERR.CC_NO_DISPATCHER_FOUND);
    }

    const { stateToPropMapping, pm, isPropStateModuleMode, mm, ccKey, connect } = props;
    let _stateToPropMapping = stateToPropMapping || pm;
    let _isPropStateModuleMode = isPropStateModuleMode || mm;

    if (_stateToPropMapping === undefined) _stateToPropMapping = {};
    if (_isPropStateModuleMode === undefined) _isPropStateModuleMode = false;

    //allow use connect replace stateToPropMapping, and when use connect, isPropStateModuleMode is always true
    if (connect) {
      _stateToPropMapping = connect;
      _isPropStateModuleMode = true;
    }

    const ccClassKey = getFragmentClassKey(_stateToPropMapping);

    const { ccUniqueKey, isCcUniqueKeyAutoGenerated } = helper.computeCcUniqueKey(false, ccClassKey, ccKey, true)

    helper.buildCcClassContext(ccClassKey, MODULE_DEFAULT, [], [], [], [], _stateToPropMapping, _isPropStateModuleMode, true);
    helper.setRef(this, false, ccClassKey, ccKey, ccUniqueKey, {});

    // for CcFragment, just put ccClassKey to module's cc class keys
    const { moduleName_ccClassKeys_ } = ccContext;
    const ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, MODULE_DEFAULT);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);

    this.$$propState = ccClassKey_ccClassContext_[ccClassKey].propState || {};

    // only bind reactForceUpdateRef for CcFragment
    const reactForceUpdateRef = this.forceUpdate.bind(this);
    const ccState = {
      module: MODULE_DEFAULT, ccClassKey, ccKey, ccUniqueKey, isCcUniqueKeyAutoGenerated, stateToPropMapping: _stateToPropMapping, renderCount: 0
    };
    this.cc = {
      ccState,
      reactForceUpdate: (state, cb) => {
        ccState.renderCount += 1;
        reactForceUpdateRef(state, cb);
      },
    };

    this.state = { fragmentParams: { propState: this.$$propState, dispatch, emit, setState, setGlobalState } };
  }
  shouldComponentUpdate() {
    return false;
  }
  componentWillUnmount() {
    const { ccUniqueKey, ccClassKey } = this.cc.ccState;
    helper.unsetRef(ccClassKey, ccUniqueKey);
    if (super.componentWillUnmount) super.componentWillUnmount();
  }
  render() {
    const children = this.props.children;
    if (typeof children === 'function') {
      return children(this.state.fragmentParams) || <Fragment />;
    } else {
      return children;
    }
  }

}